"use strict";(self.webpackChunkgameworld=self.webpackChunkgameworld||[]).push([[241],{241:(i,t,s)=>{s.r(t),s.d(t,{default:()=>h});class h{constructor(i){this.board=i.board,this.size=i.size,this.ai=i.ai,this.player=1===i.ai?2:1,this.condition=i.size>=15?5:3,this.partition={left:null,right:null,top:null,bottom:null},this.w=[0,20,17,15.4,14,10],this.winningMove=1e6,this.openFour=1e5,this.fork=1e4,this.level=i.level||"medium"}setBoard(i){this.board=i}_partitionBoard(){let i=this.size-1,t=this.size-1,s=0,h=0,o=!1;for(let r=0;r<this.size;r++)for(let e=0;e<this.size;e++)0!==this.board[r][e]&&(o=!0,i=Math.min(i,r),h=Math.max(h,r),t=Math.min(t,e),s=Math.max(s,e));if(o)this.partition={left:Math.max(0,t-2),right:Math.min(this.size-1,s+2),top:Math.max(0,i-2),bottom:Math.min(this.size-1,h+2)};else{const i=Math.floor(this.size/2);this.partition={left:Math.max(0,i-2),right:Math.min(this.size-1,i+2),top:Math.max(0,i-2),bottom:Math.min(this.size-1,i+2)}}}hasNeighbors(i,t){const s=[[0,-1],[0,1],[-1,0],[1,0],[-1,-1],[-1,1],[1,-1],[1,1]];for(let[h,o]of s){let s=i+h,r=t+o;if(s>=0&&s<this.size&&r>=0&&r<this.size&&0!==this.board[s][r])return!0}return!1}winningPos(i,t,s){let h,o,r,e,a=0,n=0,d=this.condition,l=1,b=1;for(;t+b<this.size&&this.board[i][t+b]===s;)l++,b++;for(r=b,b=1;t-b>=0&&this.board[i][t-b]===s;)l++,b++;if(e=b,l>=d)return this.winningMove;for(h=t-e>=0&&0===this.board[i][t-e],o=t+r<this.size&&0===this.board[i][t+r],l===d-1&&(h||o)&&a++,h&&o&&(l===d-1?n++:l===d-2&&a++),l=1,b=1;i+b<this.size&&this.board[i+b][t]===s;)l++,b++;for(r=b,b=1;i-b>=0&&this.board[i-b][t]===s;)l++,b++;if(e=b,l>=d)return this.winningMove;for(h=i-e>=0&&0===this.board[i-e][t],o=i+r<this.size&&0===this.board[i+r][t],l===d-1&&(h||o)&&a++,h&&o&&(l===d-1?n++:l===d-2&&a++),l=1,b=1;i+b<this.size&&t+b<this.size&&this.board[i+b][t+b]===s;)l++,b++;for(r=b,b=1;i-b>=0&&t-b>=0&&this.board[i-b][t-b]===s;)l++,b++;if(e=b,l>=d)return this.winningMove;for(h=i-e>=0&&t-e>=0&&0===this.board[i-e][t-e],o=i+r<this.size&&t+r<this.size&&0===this.board[i+r][t+r],l===d-1&&(h||o)&&a++,h&&o&&(l===d-1?n++:l===d-2&&a++),l=1,b=1;i-b>=0&&t+b<this.size&&this.board[i-b][t+b]===s;)l++,b++;for(r=b,b=1;i+b<this.size&&t-b>=0&&this.board[i+b][t-b]===s;)l++,b++;return e=b,l>=d?this.winningMove:(h=i+e<this.size&&t-e>=0&&0===this.board[i+e][t-e],o=i-r>=0&&t+r<this.size&&0===this.board[i-r][t+r],l===d-1&&(h||o)&&a++,h&&o&&(l===d-1?n++:l===d-2&&a++),0!==n?this.openFour:a>=2?this.fork:-1)}evaluatePos(i,t){let s=-1;const{left:h,top:o,right:r,bottom:e}=this.partition,a=1===t?2:1;for(let n=o;n<=e;n++)for(let o=h;o<=r;o++){if(0!==this.board[n][o]||!this.hasNeighbors(n,o)){i[n][o]=-1;continue}let h=this.winningPos(n,o,t);if(h>0)i[n][o]=h;else{let s=[1,1,1,1],h=[0,0,0,0],r=[0,0,0,0],e=Math.max(o-this.condition-1,0),d=Math.min(o+this.condition,this.size),l=Math.max(n-this.condition-1,0),b=Math.min(n+this.condition,this.size),f=1;for(;o+f<d&&this.board[n][o+f]!==a;)s[0]++,r[0]+=this.w[f],f++;for((o+f>=this.size||this.board[n][o+f]===a)&&(r[0]-=this.board[n][o+f-1]===t?-1*this.w[this.condition]:0),f=1;o-f>=e&&this.board[n][o-f]!==a;)s[0]++,r[0]+=this.w[f],f++;for((o-f<0||this.board[n][o-f]===a)&&(r[0]-=this.board[n][o-f+1]===t?-1*this.w[this.condition]:0),h[0]=s[0]>this.condition-1?r[0]*r[0]:0,f=1;n+f<b&&this.board[n+f][o]!==a;)s[1]++,r[1]+=this.w[f],f++;for((n+f>=this.size||this.board[n+f][o]===a)&&(r[1]-=this.board[n+f-1][o]===t?-1*this.w[this.condition]:0),f=1;n-f>=l&&this.board[n-f][o]!==a;)s[1]++,r[1]+=this.w[f],f++;for((n-f<0||this.board[n-f][o]===a)&&(r[1]-=this.board[n-f+1][o]===t?-1*this.w[this.condition]:0),h[1]=s[1]>this.condition-1?r[1]*r[1]:0,f=1;n+f<b&&o+f<d&&this.board[n+f][o+f]!==a;)s[2]++,r[2]+=this.w[f],f++;for((n+f>=this.size||o+f>=this.size||this.board[n+f][o+f]===a)&&(r[2]-=this.board[n+f-1][o+f-1]===t?-1*this.w[this.condition]:0),f=1;n-f>=l&&o-f>=e&&this.board[n-f][o-f]!==a;)s[2]++,r[2]+=this.w[f],f++;for((n-f<0||o-f<0||this.board[n-f][o-f]===a)&&(r[2]-=this.board[n-f+1][o-f+1]===t?-1*this.w[this.condition]:0),h[2]=s[2]>this.condition-1?r[2]*r[2]:0,f=1;n+f<b&&o-f>=e&&this.board[n+f][o-f]!==a;)s[3]++,r[3]+=this.w[f],f++;for((n+f>=this.size||o-f<0||this.board[n+f][o-f]===a)&&(r[3]-=this.board[n+f-1][o-f+1]===t?-1*this.w[this.condition]:0),f=1;n-f>=l&&o+f<d&&this.board[n-f][o+f]!==a;)s[3]++,r[3]+=this.w[f],f++;(n-f<0||o+f>=this.size||this.board[n-f][o+f]===a)&&(r[3]-=this.board[n-f+1][o+f-1]===t?-1*this.w[this.condition]:0),h[3]=s[3]>this.condition-1?r[3]*r[3]:0;let z=0,m=0;for(let i=0;i<=3;i++)h[i]>=z&&(m=z,z=h[i]);i[n][o]=z+m}i[n][o]>s&&(s=i[n][o])}return s}getBestMove(){this._partitionBoard();let i=Array.from({length:this.size},()=>Array(this.size).fill(0)),t=Array.from({length:this.size},()=>Array(this.size).fill(0)),s=this.evaluatePos(i,this.player),h=this.evaluatePos(t,this.ai),o=[];const{left:r,top:e,right:a,bottom:n}=this.partition;for(let b=e;b<=n;b++)for(let e=r;e<=a;e++)if(t[b][e]>-1||i[b][e]>-1){let r=h>=s?t[b][e]:i[b][e]*i[b][e];o.push({value:r,index:[b,e]})}if(0===o.length){let i=Math.floor(this.size/2);return{r:i,c:i}}let d;o.sort((i,t)=>t.value-i.value),d="hard"===this.level?Math.min(1,o.length):"medium"===this.level?Math.min(2,o.length):Math.min(4,o.length);let l=Math.floor(Math.random()*d);return{r:o[l].index[0],c:o[l].index[1]}}}}}]);
//# sourceMappingURL=241.13605963.chunk.js.map